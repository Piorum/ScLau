using Microsoft.AspNetCore.Mvc;
using ChatBackend.Models;
using System.Text.Json;
using System.Text;
using ChatBackend.Interfaces;

namespace ChatBackend.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ChatsController(IChatCache chatCache, IChatProviderFactory chatProviderFactory) : ControllerBase
{
    private readonly IChatCache _chatCache = chatCache;
    private readonly IChatProviderFactory _chatProviderFactory = chatProviderFactory;

    // GET /api/chats
    // Returns list of chat ids, last message time, title
    [HttpGet]
    public IActionResult GetChats()
    {
        return Ok(_chatCache.ListChats());
    }

    // GET /api/chats/{chatId}
    // Streams specified chat's message history
    [HttpGet("{chatId:guid}")]
    public async Task<IActionResult> GetChat(Guid chatId)
    {
        var history = await _chatCache.GetChatHistory(chatId);

        if (history is null)
            return NotFound();

        await StreamExistingMessagesAsync(history.Messages);
        return new EmptyResult();
    }

    // DELETE /api/chats/{chatId}
    // Deletes specified chat
    [HttpDelete("{chatId:guid}")]
    public async Task<IActionResult> DeleteChat(Guid chatId)
    {
        if (await _chatCache.RemoveChatHistory(chatId))
            return NoContent();

        return NotFound();
    }

    // GET /api/chats/{chatId}/title
    // Request specified chat's title generated by model
    [HttpGet("{chatId:guid}/title")]
    public async Task<IActionResult> GetTitle(Guid chatId)
    {
        var history = await _chatCache.GetChatHistory(chatId);
        if (history is not null)
        {
            if (history!.LastChatOptions is null || history.Messages.Count == 0)
                return NotFound($"Chat with ID \"{chatId}\" has no valid last options or not enough messages to generate a title.");

            var provider = _chatProviderFactory.GetProvider(history.LastChatOptions.ChatProvider);
            ChatHistory prompt = new();
            StringBuilder sb = new();
            for (var i = history.Messages.Count - 1; i >= 0; i--)
            {
                var message = history.Messages[i];
                
                if(message.ContentType != ContentType.Reasoning)
                    sb.Insert(0, $"{message.Role}: \"{message.Content}\"\n\n");

                if (message.Role == MessageRole.User)
                    break;
            }
            sb.Insert(0, "Chat Excerpt.\n\n");

            prompt.Messages.Add(ChatMessage.CreateSystemMessage(Guid.NewGuid(), sb.ToString()));

            sb.Clear();
            await foreach (var response in provider.ContinueChatAsync(prompt, new() { SystemMessage = "Summarize the following chat excerpt into a 3-5 word title." }).ReadAllAsync())
            {
                if (response.ContentType == ContentType.Answer)
                    sb.Append(response.ContentChunk);
            }

            history.Title = sb.ToString().Trim();
            await _chatCache.UpdateChatHistory(history);
            return Ok(history.Title);
        }

        return NotFound($"Chat with ID \"{chatId}\" not found.");
    }

    // PUT /api/chats/{chatId}/title
    // Updates specified chat's title
    [HttpPut("{chatId:guid}/title")]
    public async Task<IActionResult> ReplaceTitle(Guid chatId, [FromBody] PostTitleRequest request)
    {
        var history = await _chatCache.GetChatHistory(chatId);
        if (history is not null)
        {
            history!.Title = request.Title;
            await _chatCache.UpdateChatHistory(history);
            return NoContent();
        }

        return NotFound($"Chat with ID \"{chatId}\" not found.");
    }


    // POST /api/chats/{chatId}/messages
    // Appends valid user prompts and continues chat, streams AI's response
    [HttpPost("{chatId:guid}/messages")]
    public async Task PostMessage(Guid chatId, [FromBody] PostMessageRequest request)
    {
        var history = await _chatCache.GetOrCreateChatHistory(chatId);

        if (!string.IsNullOrEmpty(request.UserPrompt))
            history.Messages.Add(ChatMessage.CreateUserMessage(request.UserMessageId, request.UserPrompt));

        var options = request.Options ?? new ChatOptions();
        await StreamChatResponse(history, options);
    }

    // DELETE chats/{chatId}/messages/{messageId}
    // Deletes specified message from specified chat
    [HttpDelete("{chatId:guid}/messages/{messageId:guid}")]
    public async Task<IActionResult> DeleteMessage(Guid chatId, Guid messageId)
    {
        var history = await _chatCache.GetChatHistory(chatId);
        if (history is not null)
        {
            if (history!.Messages.RemoveAll(e => e.MessageId == messageId) > 0)
            {
                await _chatCache.UpdateChatHistory(history);
                return NoContent();
            }
                
            return NotFound($"Message with ID \"{messageId}\" not found in chat with ID \"{chatId}\".");
        }
        return NotFound($"Chat with ID \"{chatId}\" not found.");
    }

    // PUT chats/{chatId}/messages/{messageId}
    // Edits message content of a specified message from specified chat
    [HttpPut("{chatId:guid}/messages/{messageId:guid}")]
    public async Task<IActionResult> EditMessage(Guid chatId, Guid messageId, [FromBody] PostMessageContentRequest request)
    {
        var history = await _chatCache.GetChatHistory(chatId);
        if (history is not null)
        {
            var message = history!.Messages.FirstOrDefault(e => e.MessageId == messageId);
            if (message is not null)
            {
                if (message.Role != MessageRole.Tool)
                    message.Content = request.Content;
                else
                    message.ToolContext = message.ToolContext! with { Content = request.Content };

                await _chatCache.UpdateChatHistory(history);
                return NoContent();
            }
            return NotFound($"Message with ID \"{messageId}\" not found in chat with ID \"{chatId}\".");
        }
        return NotFound($"Chat with ID \"{chatId}\" not found.");
    }

    // POST chats/{chatId}/messages/{messageId}/regenerate
    // Deletes all messages past the last user message before the specified message and re-prompts AI, streams AI's response
    [HttpPost("{chatId:guid}/messages{messageId:guid}/regenerate")]
    public async Task<IActionResult> PostRegenerateMessage(Guid chatId, Guid messageId, [FromBody] PostMessageRequest request)
    {
        var history = await _chatCache.GetChatHistory(chatId);
        if (history is null)
            return NotFound($"Chat with ID \"{chatId}\" not found.");

        var messages = history!.Messages;
        var targetIndex = messages.FindIndex(m => m.MessageId == messageId);
        if (targetIndex == -1)
            return NotFound($"Message with ID \"{messageId}\" not found in chat with ID \"{chatId}\".");

        int lastUserIndex = -1;
        for (int i = targetIndex; i >= 0; i--)
            if (messages[i].Role == MessageRole.User)
            {
                lastUserIndex = i;
                break;
            }

        if (lastUserIndex == -1)
            return NotFound($"No user message found before message with ID \"{messageId}\" in chat with ID \"{chatId}\".");

        if (lastUserIndex < messages.Count - 1)
        {
            messages.RemoveRange(lastUserIndex + 1, messages.Count - (lastUserIndex + 1));
            await _chatCache.UpdateChatHistory(history);
        }

        var options = request.Options ?? new ChatOptions();
        await StreamChatResponse(history, options);

        return new EmptyResult();

    }

    // GET chats/{chatId}/messages/{messageId}/branch
    // Creates a new chat with a copy of the messages in the specified chat up to the specified message.
    [HttpGet("{chatId:guid}/messages/{messageId:guid}/branch")]
    public async Task<IActionResult> GetBranch(Guid chatId, Guid messageId)
    {
        var baseHistory = await _chatCache.GetChatHistory(chatId);
        if (baseHistory is null)
            return NotFound($"Chat with ID \"{chatId}\" not found.");

        var branchPointIndex = baseHistory!.Messages.FindIndex(m => m.MessageId == messageId);
        if (branchPointIndex == -1)
        {
            return NotFound($"Message with ID \"{messageId}\" not found in chat with ID \"{chatId}\".");
        }

        var newMessages = baseHistory.Messages.GetRange(0, branchPointIndex + 1);

        ChatHistory newHistory = new();
        newHistory.Messages.AddRange(newMessages);
        newHistory.Title = baseHistory.Title;

        var newChatId = await _chatCache.CreateChatHistory(newHistory);

        Response.Headers.Append("X-New-Chat-Id", newChatId.ToString());
        await StreamExistingMessagesAsync(newHistory.Messages);

        return new EmptyResult();
    }
    
    private async Task StreamExistingMessagesAsync(IEnumerable<ChatMessage> messages)
    {
        Response.ContentType = "application/x-ndjson";

        foreach (var message in messages)
        {
            // Process the content of each message for client-side rendering
            var processedMessage = message with { Content = LatexStreamRewriter.ProcessString(message.Role != MessageRole.Tool ? message.Content! : message.ToolContext!.Content ) };
            var jsonChunk = JsonSerializer.Serialize(processedMessage);
            await Response.WriteAsync(jsonChunk + "\n");
            await Response.Body.FlushAsync();
        }
    }

    private async Task StreamChatResponse(ChatHistory history, ChatOptions options)
    {
        history.LastChatOptions = options;

        //These will be moved to the frontend eventually
        options.ChatProvider = nameof(HarmonyFormatProvider);
        options.SystemMessage = "Fulfill the request to the best of your abilities.";
        options.ModelOptions = new() { Temperature = 1.2f };
        options.EnabledTools = ["get_current_weather"];

        LatexStreamRewriter lsr = new();
        Response.ContentType = "application/x-ndjson";

        await foreach (var response in _chatProviderFactory.GetProvider(options.ChatProvider).ContinueChatAsync(history, options).ReadAllAsync())
        {
            response.ContentChunk = lsr.ProcessChunk(response.ContentChunk);
            var jsonChunk = JsonSerializer.Serialize(response);
            await Response.WriteAsync(jsonChunk + "\n");
            await Response.Body.FlushAsync();
        }

        await _chatCache.UpdateChatHistory(history);
    }

    private class LatexStreamRewriter
    {
        private bool waitingForNext = false;
        private readonly StringBuilder sb = new();

        public string ProcessChunk(string token)
        {
            sb.Clear();

            foreach (var c in token)
                if (waitingForNext)
                {
                    switch (c)
                    {
                        case '(':
                        case ')':
                            sb.Append('$');
                            break;
                        case '[':
                        case ']':
                            sb.Append("$$");
                            break;
                        default:
                            sb.Append('\\').Append(c); // not math, output the backslash + current char
                            break;
                    }

                    waitingForNext = false;
                }
                else
                    if (c == '\\')
                    waitingForNext = true; // hold until next character
                else
                    sb.Append(c);

            return $"{sb}";
        }

        public static string ProcessString(string input)
        {
            var lsr = new LatexStreamRewriter();
            return lsr.ProcessChunk(input);
        }
    }
}

// DTOs for the request bodies
public class PostTitleRequest
{
    public string Title { get; set; } = "";
}

public class PostMessageRequest
{
    public string UserPrompt { get; set; } = "";
    public Guid UserMessageId { get; set; }
    public ChatOptions? Options { get; set; }
}

public class PostMessageContentRequest
{
    public string Content { get; set; } = "";
}